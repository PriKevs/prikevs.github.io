{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":1},{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":1},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":1}],"Cache":[{"_id":"source/_posts/add-authentication-to-ngrok.md","shasum":"85784d79b58983aaac023d155a1772312fe0b615","modified":1482744137000},{"_id":"source/_posts/auto-build-system-for-chromium.md","shasum":"c485137fc7dfcfcf56a6e9a76ba77cb1fccd1bcf","modified":1482744137000},{"_id":"source/_posts/remote-control-based-on-websocket.md","shasum":"54fb1221ac083ea587d860c3c993b70796e49434","modified":1482744137000},{"_id":"themes/apollo/LICENSE","shasum":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1482744137000},{"_id":"themes/apollo/README.md","shasum":"a6930c691c69ed78584022fbcd0f4245587d09f5","modified":1482744137000},{"_id":"themes/apollo/_config.yml","shasum":"cbf7806080e60718393ec70dcfab108a046cb41b","modified":1482744137000},{"_id":"themes/apollo/doc/doc-en.md","shasum":"1bccce1d01f085aedcb01317d2db23ca61351f13","modified":1482744137000},{"_id":"themes/apollo/doc/doc-zh.md","shasum":"3aad2ed65922f6f5dd9731301195474d16a8a9be","modified":1482744137000},{"_id":"themes/apollo/gulpfile.js","shasum":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1482744137000},{"_id":"themes/apollo/languages/en.yml","shasum":"65998758dd27a350b6d4f2dc803970a9c89978da","modified":1482744137000},{"_id":"themes/apollo/languages/zh-cn.yml","shasum":"4d65eeec01b5cfa7ab81363c089838c9dac827fb","modified":1482744137000},{"_id":"themes/apollo/layout/archive.jade","shasum":"62797414355bf4474092bc3a32726c8340820ffb","modified":1482744137000},{"_id":"themes/apollo/layout/index.jade","shasum":"58c451042cad5beeb5a76852bba609c651ff3428","modified":1482744137000},{"_id":"themes/apollo/layout/mixins/paginator.jade","shasum":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1482744137000},{"_id":"themes/apollo/layout/mixins/post.jade","shasum":"0cbaf05d3b19b99dffaabd0e407e398db72624cc","modified":1482744137000},{"_id":"themes/apollo/layout/partial/comment.jade","shasum":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1482744137000},{"_id":"themes/apollo/layout/partial/copyright.jade","shasum":"2e2ee43c7241279a32b8c1386a2dea1409ef0e1c","modified":1482744137000},{"_id":"themes/apollo/layout/partial/head.jade","shasum":"63688749707b4c1fe95a4e841d814c6a8880c965","modified":1482744137000},{"_id":"themes/apollo/layout/partial/layout.jade","shasum":"d596c281bbba02cf8837f25f8ac0ac06e3d10e72","modified":1482744137000},{"_id":"themes/apollo/layout/partial/nav.jade","shasum":"c35d3061da4b053b73150d9741c542d660798270","modified":1482744137000},{"_id":"themes/apollo/layout/partial/scripts.jade","shasum":"4c83fec1e2fc5cffefafc2e31835e28122c0fdfd","modified":1482744137000},{"_id":"themes/apollo/layout/post.jade","shasum":"33ab46ab3736e5d51388939858647942ce375b9b","modified":1482744137000},{"_id":"themes/apollo/package.json","shasum":"9426138c09ebb95969021d951590c0c54b187a43","modified":1482744137000},{"_id":"themes/apollo/source/css/apollo.css","shasum":"6d3693b5efda5588a25d78f4202bcc11fc969cbe","modified":1482744137000},{"_id":"themes/apollo/source/favicon.png","shasum":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1482744137000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","shasum":"58af2a0803d9e306a7715a65e3464f04cfa68e9a","modified":1482744137000},{"_id":"themes/apollo/source/scss/_partial/base.scss","shasum":"88b361e68475caddbab763feed5e1db788ac2cd7","modified":1482744137000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","shasum":"7fc843c37a4dbf9f6e70770398841a73465ec642","modified":1482744137000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","shasum":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1482744137000},{"_id":"themes/apollo/source/scss/_partial/header.scss","shasum":"d24cc6520f3faa7bb80610b858a92639eadcc289","modified":1482744137000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","shasum":"92858015b8f3dcb4eb91b6dc41563b7aaa91b376","modified":1482744137000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","shasum":"0b9c7097136ac8e4a07d9702fc4dbe0345ac7596","modified":1482744137000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","shasum":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1482744137000},{"_id":"themes/apollo/source/scss/_partial/post.scss","shasum":"3ba64c410edd07e7bf5e9900d9ad9d76f2ff5828","modified":1482744137000},{"_id":"themes/apollo/source/scss/apollo.scss","shasum":"a3153dfedbaff08c20930b2bde95f2db49f6d518","modified":1482744137000},{"_id":"public/scss/apollo.scss","modified":1482748518047,"shasum":"a3153dfedbaff08c20930b2bde95f2db49f6d518"},{"_id":"public/favicon.png","modified":1482748518059,"shasum":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c"},{"_id":"public/css/apollo.css","modified":1482748518063,"shasum":"6d3693b5efda5588a25d78f4202bcc11fc969cbe"},{"_id":"public/2016/12/26/auto-build-system-for-chromium/index.html","modified":1482748518394,"shasum":"f5e44dc6938358227ff88ed463ce2f8d2c1e28e9"},{"_id":"public/2016/12/26/add-authentication-to-ngrok/index.html","modified":1482748518567,"shasum":"4939b91527341b8efceafba36424c43f9c6a8ac9"},{"_id":"public/2015/12/16/remote-control-based-on-websocket/index.html","modified":1482748518661,"shasum":"bcd237f5c2fb74f3c161e247c97fa5f645793134"},{"_id":"public/archives/index.html","modified":1482748518728,"shasum":"d0bcfef112388fa719eea4216e6dc7b36661e733"},{"_id":"public/archives/2015/index.html","modified":1482748518814,"shasum":"5b069a322a441af225af6dd1137538a50ce176fa"},{"_id":"public/archives/2015/12/index.html","modified":1482748518868,"shasum":"5b069a322a441af225af6dd1137538a50ce176fa"},{"_id":"public/archives/2016/index.html","modified":1482748518958,"shasum":"549bbdde32c2a6de99efebe8d6575e88d7701230"},{"_id":"public/archives/2016/12/index.html","modified":1482748519043,"shasum":"549bbdde32c2a6de99efebe8d6575e88d7701230"},{"_id":"public/atom.xml","modified":1482748519046,"shasum":"b4dff2e64bee0dee20d948b36650da431d038d58"},{"_id":"public/index.html","modified":1482748519141,"shasum":"d94588a4827866282ed074d374fea2dfa7a5b5bd"},{"_id":"public/sitemap.xml","modified":1482748519142,"shasum":"a059c711f35672ab44dc728f4b688aa507ee3560"},{"_id":"public/tags/ngrok/index.html","modified":1482748519214,"shasum":"bcec61f0c3b92f2e4415937b2ee4bb890a0c2976"},{"_id":"public/tags/golang/index.html","modified":1482748519287,"shasum":"bcec61f0c3b92f2e4415937b2ee4bb890a0c2976"},{"_id":"public/tags/websocket/index.html","modified":1482748519363,"shasum":"5b069a322a441af225af6dd1137538a50ce176fa"}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"给ngrok添加身份验证","date":"2016-12-25T16:00:00.000Z","_content":"\n## 需求 ##\n\n最近有个同学需要在校外访问学校内网，然而学校的SSL VPN出了问题，只能用自己的方式来解决了。\n听到这个需求，我的第一反应是用N2N VPN，使用UDP Hole Punching的方式来穿透学校内网组建VPN。\n于是立马写了一套简单的工具来检测学校的网络是否支持UPD Hole Punching，不过这不是今天的主题，以后有机会再说。\n\n由于N2N年久失修，对Mac用户也不友好，我最终使用来一个更简单的方式——在内网本地搭一个shadowsoks的server，然后用ngrok将端口暴露到外网服务器，直接用ss的客户端就可以将流量转接到本地了。\n\n首先我简单介绍一下ngrok:\n\n> [ngrok](https://github.com/inconshreveable/ngrok) \n> is a reverse proxy that creates a secure tunnel from a public endpoint to a locally running web service.\n> ngrok captures and analyzes all traffic over the tunnel for later inspection and replay.\n\n简单来说，ngrok最主要的功能就是将本地的端口映射到外网的某个端口，以方便地完成很多需要外网访问却不希望deploy在服务器上的功能，比如现场demo、临时分享等。\n\n目前ngrok有两种版本，一个是开源但是几近停止维护的ngrok 1.x，还有一个是闭源商用的ngrok 2.x。\n这里我们选用1.x，方便self hosting部署以及自定义功能比如本文的题目：添加身份验证。\n\n我们可以根据[Self Hosting Doc](https://github.com/inconshreveable/ngrok/blob/master/docs/SELFHOSTING.md)的文档完成最初的部署。\n然而部署完我们会发现，原始版本的ngrok的server是没有身份验证功能的，也就是说任何人都可以通过ngrok 1.x的client使用我们的服务器，毕竟是私人的服务器，所以我希望给ngrok加上身份验证的功能。\n\n## 分析 ##\n\n下面我们开始分析相关的ngrok的源代码。\n\n`src/ngrok/server/control.go#func NewControl`\n```\nfunc NewControl(ctlConn conn.Conn, authMsg *msg.Auth) {\n\n\t...\n\n\tfailAuth := func(e error) {\n\t\t_ = msg.WriteMsg(ctlConn, &msg.AuthResp{Error: e.Error()})\n\t\tctlConn.Close()\n\t}\n\n\t// register the clientid\n\tc.id = authMsg.ClientId\n\tif c.id == \"\" {\n\t\t// it's a new session, assign an ID\n\t\tif c.id, err = util.SecureRandId(16); err != nil {\n\t\t\tfailAuth(err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t...\n\n}\n```\n\n我们发现这一段代码实现的正是某种访问控制的功能，这个`authMsg`里说不定包含了一些我们需要的验证信息，下面我们查看`authMsg`的定义。\n\n`src/ngrok/msg/msg.go#Auth struct`\n```\n// When a client opens a new control channel to the server\n// it must start by sending an Auth message.\ntype Auth struct {\n\tVersion   string // protocol version\n\tMmVersion string // major/minor software version (informational only)\n\tUser      string\n\tPassword  string\n\tOS        string\n\tArch      string\n\tClientId  string // empty for new sessions\n}\n\n```\n\n这里我们看到了`User`和`Password`，下意识觉得这里有戏，我们需要查证这两个值的来源。\n我们可以在client中寻找对应的参数设定位置。\n\n<过程略……>\n\n最终我们会发现，`Auth struct`中的User对应的正是client命令行参数中的`-authtoken`\n因此，我们可以在-authtoken中包含我们的验证信息。\n\n## 实现 ##\n\n我们采用`-authtoken='username:password'`的方式来进行验证。具体实现的话只需要在`src/ngrok/server/control.go#func NewControl`中添加对`Auth struct`中的`User`验证的方法就行。\n\n我的实现方案是，可以手动创建并用`-secretPath`指定（默认在`/etc/ngrok-secrets`）存储用户名和密码的文件的位置，格式为：\n\n```\n# username      password\n  example-user  example-password\n```\n\n具体实现可以见我fork之后的[commit: add support to authenticate by token](https://github.com/prikevs/ngrok/commit/aa9b88d4e070069db6d8f88aa82526bcbcd1d0b6)\n\n以后使用时只需要加上-authtoken参数即可，如:\n```\n$ ngrok -authtoken=\"username:password\" -proto=tcp 8888\n```\n\n## 总结 ##\n\n我只是添加了很简单的一种身份验证方式，大家其实可以根据自己的需求与其他验证系统结合起来=)\n\n","source":"_posts/add-authentication-to-ngrok.md","raw":"---\ntitle: 给ngrok添加身份验证\ndate: 2016-12-26\ntags:\n- ngrok\n- golang\n---\n\n## 需求 ##\n\n最近有个同学需要在校外访问学校内网，然而学校的SSL VPN出了问题，只能用自己的方式来解决了。\n听到这个需求，我的第一反应是用N2N VPN，使用UDP Hole Punching的方式来穿透学校内网组建VPN。\n于是立马写了一套简单的工具来检测学校的网络是否支持UPD Hole Punching，不过这不是今天的主题，以后有机会再说。\n\n由于N2N年久失修，对Mac用户也不友好，我最终使用来一个更简单的方式——在内网本地搭一个shadowsoks的server，然后用ngrok将端口暴露到外网服务器，直接用ss的客户端就可以将流量转接到本地了。\n\n首先我简单介绍一下ngrok:\n\n> [ngrok](https://github.com/inconshreveable/ngrok) \n> is a reverse proxy that creates a secure tunnel from a public endpoint to a locally running web service.\n> ngrok captures and analyzes all traffic over the tunnel for later inspection and replay.\n\n简单来说，ngrok最主要的功能就是将本地的端口映射到外网的某个端口，以方便地完成很多需要外网访问却不希望deploy在服务器上的功能，比如现场demo、临时分享等。\n\n目前ngrok有两种版本，一个是开源但是几近停止维护的ngrok 1.x，还有一个是闭源商用的ngrok 2.x。\n这里我们选用1.x，方便self hosting部署以及自定义功能比如本文的题目：添加身份验证。\n\n我们可以根据[Self Hosting Doc](https://github.com/inconshreveable/ngrok/blob/master/docs/SELFHOSTING.md)的文档完成最初的部署。\n然而部署完我们会发现，原始版本的ngrok的server是没有身份验证功能的，也就是说任何人都可以通过ngrok 1.x的client使用我们的服务器，毕竟是私人的服务器，所以我希望给ngrok加上身份验证的功能。\n\n## 分析 ##\n\n下面我们开始分析相关的ngrok的源代码。\n\n`src/ngrok/server/control.go#func NewControl`\n```\nfunc NewControl(ctlConn conn.Conn, authMsg *msg.Auth) {\n\n\t...\n\n\tfailAuth := func(e error) {\n\t\t_ = msg.WriteMsg(ctlConn, &msg.AuthResp{Error: e.Error()})\n\t\tctlConn.Close()\n\t}\n\n\t// register the clientid\n\tc.id = authMsg.ClientId\n\tif c.id == \"\" {\n\t\t// it's a new session, assign an ID\n\t\tif c.id, err = util.SecureRandId(16); err != nil {\n\t\t\tfailAuth(err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t...\n\n}\n```\n\n我们发现这一段代码实现的正是某种访问控制的功能，这个`authMsg`里说不定包含了一些我们需要的验证信息，下面我们查看`authMsg`的定义。\n\n`src/ngrok/msg/msg.go#Auth struct`\n```\n// When a client opens a new control channel to the server\n// it must start by sending an Auth message.\ntype Auth struct {\n\tVersion   string // protocol version\n\tMmVersion string // major/minor software version (informational only)\n\tUser      string\n\tPassword  string\n\tOS        string\n\tArch      string\n\tClientId  string // empty for new sessions\n}\n\n```\n\n这里我们看到了`User`和`Password`，下意识觉得这里有戏，我们需要查证这两个值的来源。\n我们可以在client中寻找对应的参数设定位置。\n\n<过程略……>\n\n最终我们会发现，`Auth struct`中的User对应的正是client命令行参数中的`-authtoken`\n因此，我们可以在-authtoken中包含我们的验证信息。\n\n## 实现 ##\n\n我们采用`-authtoken='username:password'`的方式来进行验证。具体实现的话只需要在`src/ngrok/server/control.go#func NewControl`中添加对`Auth struct`中的`User`验证的方法就行。\n\n我的实现方案是，可以手动创建并用`-secretPath`指定（默认在`/etc/ngrok-secrets`）存储用户名和密码的文件的位置，格式为：\n\n```\n# username      password\n  example-user  example-password\n```\n\n具体实现可以见我fork之后的[commit: add support to authenticate by token](https://github.com/prikevs/ngrok/commit/aa9b88d4e070069db6d8f88aa82526bcbcd1d0b6)\n\n以后使用时只需要加上-authtoken参数即可，如:\n```\n$ ngrok -authtoken=\"username:password\" -proto=tcp 8888\n```\n\n## 总结 ##\n\n我只是添加了很简单的一种身份验证方式，大家其实可以根据自己的需求与其他验证系统结合起来=)\n\n","slug":"add-authentication-to-ngrok","published":1,"updated":"2016-12-26T09:22:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix5y6mcp0000cv9kovi3sx8y"},{"title":"基于WebSocket的网页遥控器","date":"2015-12-15T16:00:00.000Z","_content":"## 场景 ##\n前段时间有一个小需求，场景是装着Ubuntu的笔记本放在书桌上连着音箱用网页版的网易云音乐放歌，每次睡觉前我都要从床上爬起来去手动暂停播放，十分影响舒适度。于是便希望有种方法能够通过手机远程控制播放器的暂停。\n\n## 实现 ##\n由于播放器是基于Web的且我没有开发手机app的条件，于是便准备从Web着手，首选的通信方式当然是WebSocket。实现的方法是写一个Chrome的小插件，用来在网页中注入JS代码，而这段JS的功能就是与中继服务器建立WebSocket连接，并通过解析接收到的指令对网页上的元素进行对应的操作，比如click暂停/播放、下一首、上一首等按钮。\n\n有一个比较关键的地方就是中继服务器实现的对于WebSocket发送内容的中继。我采用了Gorilla的WebSocket库，并在其examples/chat上进行的修改，加入了Channel的功能，即只要连上同样的URL就是加入同一个频道，来实现中继通信。\n于是最终的流程就是：\n1.  在中继服务器上建立Web Server\n1.  控制端访问获取控制页面，页面上的JS使用WebSocket加入Channel A\n1.  被控制端在需要控制的网页注入JS，同样加入Channel A\n1.  控制端与被控制端建立通信\n\n源代码：[github](https://github.com/prikevs/WSChannel)\n\n## 拓展 ##\n可以作为网页遥控器来使用，比如控制基于Web的PPT等。\n\n## 后记 ##\n直到我后来发现了peer.js，才发现自己走到沟里去了……\n","source":"_posts/remote-control-based-on-websocket.md","raw":"---\ntitle: 基于WebSocket的网页遥控器\ndate: 2015-12-16\ntags:\n- websocket\n---\n## 场景 ##\n前段时间有一个小需求，场景是装着Ubuntu的笔记本放在书桌上连着音箱用网页版的网易云音乐放歌，每次睡觉前我都要从床上爬起来去手动暂停播放，十分影响舒适度。于是便希望有种方法能够通过手机远程控制播放器的暂停。\n\n## 实现 ##\n由于播放器是基于Web的且我没有开发手机app的条件，于是便准备从Web着手，首选的通信方式当然是WebSocket。实现的方法是写一个Chrome的小插件，用来在网页中注入JS代码，而这段JS的功能就是与中继服务器建立WebSocket连接，并通过解析接收到的指令对网页上的元素进行对应的操作，比如click暂停/播放、下一首、上一首等按钮。\n\n有一个比较关键的地方就是中继服务器实现的对于WebSocket发送内容的中继。我采用了Gorilla的WebSocket库，并在其examples/chat上进行的修改，加入了Channel的功能，即只要连上同样的URL就是加入同一个频道，来实现中继通信。\n于是最终的流程就是：\n1.  在中继服务器上建立Web Server\n1.  控制端访问获取控制页面，页面上的JS使用WebSocket加入Channel A\n1.  被控制端在需要控制的网页注入JS，同样加入Channel A\n1.  控制端与被控制端建立通信\n\n源代码：[github](https://github.com/prikevs/WSChannel)\n\n## 拓展 ##\n可以作为网页遥控器来使用，比如控制基于Web的PPT等。\n\n## 后记 ##\n直到我后来发现了peer.js，才发现自己走到沟里去了……\n","slug":"remote-control-based-on-websocket","published":1,"updated":"2016-12-26T09:22:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix5y6mdc0005cv9k14k8zak9"},{"title":"Auto Build System for Chromium","_content":"\n新学期刚开始没多久便拿到了Intel上海的实习Offer，于是选择了翘课实习，至今已经三多月了。\n实习第一个阶段的任务便是开发一个针对Chromium的自动化编译平台。\n\n## 需求 ##\n按照最初的需求，新平台包含以下功能:\n*   Auto fetch and build Chromium project at regular time.\n*   Build commits according to demand.\n*   Quick query to a commit and download built binaries.\n\n后来经过我提议，决定搭建一个**分布式编译集群**，采用Master-Slave结构，将组里淘汰下来的旧电脑充分利用，作为build worker加入Machine pool。\n\n## 设计 ##\n系统主要分成四个模块：**Master**, **Collector**, **Database**, **Worker**\n\n其中的**Master**，**Collector**，**Database**相当于Master-Slave结构中的Master，而Worker就是Slave,\n结构关系如下图所示：\n\nTBD\n\n*   **Master**\n通过消息队列与Worker进行交互，提供数据库管理、添加build任务等操作的API。提供Admin Site给用户进行基于Web的可视化管理。\n    *   Admin Site: 给用户提供可视化的管理界面\n    *   Database API: 封装SQLAlchemy给其他功能提供数据库操作API\n    *   Database Keeper: 监听消息队列中的任务状态更新以及查询信息\n    *   Scheduler: 定期更新代码库并将新的代码库信息同步进数据库，同时将需要build的commit加入task队列。\n\n*   **Collector**\n独立于Master，负责通过HTTP接收Worker build结束之后提交的log和binaries，通过Web提供查询以及下载的API。\n\n*   **Database**\n用于存储代码库的Commit以及Branch信息，Task的build情况等，驱动Master。\n\n*   **Worker**\n每个Worker维护一个Chromium的code base，通过消息队列获取build task，包括需要build的commit的commit hash或者version No.。\nBuild的过程中通过消息队列更新当前任务的完成进度以及自身状态。Build结束后将Binaries和Log打包，通过HTTP上传给Collector，并接受下一个任务。\n\n任务分发流程：\n*   添加任务：\n\nTBD\n\n## 实现 ##\n技术栈：\n*   语言：Python3.4(后端)，HTML,CSS,JS(Admin Site前端)\n*   Web框架：[Flask](http://flask.pocoo.org/)\n*   ORM工具：[SQLAlchemy](http://www.sqlalchemy.org/)\n*   消息队列：[RabbitMQ](http://www.rabbitmq.com/)\n*   数据库：[MariaDB](https://mariadb.org/)\n\n\n## 拓展 ##\n*   增加邮件提醒功能，使用SMTPLib\n*   使用Docker快速自动化部署Worker\n\n## 总结&感想 ##\n根据需求，从设计到开发全都是一人完成，很好地锻炼了我系统模块化设计的能力。“全栈”式的开发也让我对整个系统流程有了更深的理解，为接以后的项目和工作打下了坚实基础。\n技术发展与迭代的速度很快，不能只拘泥于工具的使用，要深入理解其背后的设计逻辑，才能应得万变。\n","source":"_posts/auto-build-system-for-chromium.md","raw":"---\ntitle: Auto Build System for Chromium\n---\n\n新学期刚开始没多久便拿到了Intel上海的实习Offer，于是选择了翘课实习，至今已经三多月了。\n实习第一个阶段的任务便是开发一个针对Chromium的自动化编译平台。\n\n## 需求 ##\n按照最初的需求，新平台包含以下功能:\n*   Auto fetch and build Chromium project at regular time.\n*   Build commits according to demand.\n*   Quick query to a commit and download built binaries.\n\n后来经过我提议，决定搭建一个**分布式编译集群**，采用Master-Slave结构，将组里淘汰下来的旧电脑充分利用，作为build worker加入Machine pool。\n\n## 设计 ##\n系统主要分成四个模块：**Master**, **Collector**, **Database**, **Worker**\n\n其中的**Master**，**Collector**，**Database**相当于Master-Slave结构中的Master，而Worker就是Slave,\n结构关系如下图所示：\n\nTBD\n\n*   **Master**\n通过消息队列与Worker进行交互，提供数据库管理、添加build任务等操作的API。提供Admin Site给用户进行基于Web的可视化管理。\n    *   Admin Site: 给用户提供可视化的管理界面\n    *   Database API: 封装SQLAlchemy给其他功能提供数据库操作API\n    *   Database Keeper: 监听消息队列中的任务状态更新以及查询信息\n    *   Scheduler: 定期更新代码库并将新的代码库信息同步进数据库，同时将需要build的commit加入task队列。\n\n*   **Collector**\n独立于Master，负责通过HTTP接收Worker build结束之后提交的log和binaries，通过Web提供查询以及下载的API。\n\n*   **Database**\n用于存储代码库的Commit以及Branch信息，Task的build情况等，驱动Master。\n\n*   **Worker**\n每个Worker维护一个Chromium的code base，通过消息队列获取build task，包括需要build的commit的commit hash或者version No.。\nBuild的过程中通过消息队列更新当前任务的完成进度以及自身状态。Build结束后将Binaries和Log打包，通过HTTP上传给Collector，并接受下一个任务。\n\n任务分发流程：\n*   添加任务：\n\nTBD\n\n## 实现 ##\n技术栈：\n*   语言：Python3.4(后端)，HTML,CSS,JS(Admin Site前端)\n*   Web框架：[Flask](http://flask.pocoo.org/)\n*   ORM工具：[SQLAlchemy](http://www.sqlalchemy.org/)\n*   消息队列：[RabbitMQ](http://www.rabbitmq.com/)\n*   数据库：[MariaDB](https://mariadb.org/)\n\n\n## 拓展 ##\n*   增加邮件提醒功能，使用SMTPLib\n*   使用Docker快速自动化部署Worker\n\n## 总结&感想 ##\n根据需求，从设计到开发全都是一人完成，很好地锻炼了我系统模块化设计的能力。“全栈”式的开发也让我对整个系统流程有了更深的理解，为接以后的项目和工作打下了坚实基础。\n技术发展与迭代的速度很快，不能只拘泥于工具的使用，要深入理解其背后的设计逻辑，才能应得万变。\n","slug":"auto-build-system-for-chromium","published":1,"date":"2016-12-26T09:41:04.000Z","updated":"2016-12-26T09:22:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix5y6mdf0008cv9kjxav31m9"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cix5y6mcp0000cv9kovi3sx8y","tag_id":"cix5y6md10001cv9k95vbuofk","_id":"cix5y6md60003cv9kib8livui"},{"post_id":"cix5y6mcp0000cv9kovi3sx8y","tag_id":"cix5y6md50002cv9k9bm6yx0a","_id":"cix5y6md70004cv9khn1rhhmd"},{"post_id":"cix5y6mdc0005cv9k14k8zak9","tag_id":"cix5y6mde0006cv9k29gra0br","_id":"cix5y6mde0007cv9ko2sppuog"}],"Tag":[{"name":"ngrok","_id":"cix5y6md10001cv9k95vbuofk"},{"name":"golang","_id":"cix5y6md50002cv9k9bm6yx0a"},{"name":"websocket","_id":"cix5y6mde0006cv9k29gra0br"}]}}
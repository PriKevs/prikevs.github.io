<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kevince's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-01-24T09:40:00.563Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Kevince Boole]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Auto Build System for Chromium]]></title>
    <link href="http://yoursite.com/2016/01/24/auto-build-system-for-chromium/"/>
    <id>http://yoursite.com/2016/01/24/auto-build-system-for-chromium/</id>
    <published>2016-01-24T13:09:38.294Z</published>
    <updated>2016-01-24T09:40:00.563Z</updated>
    <content type="html"><![CDATA[<p>新学期刚开始没多久便拿到了Intel上海的实习Offer，于是选择了翘课实习，至今已经三多月了。<br>实习第一个阶段的任务便是开发一个针对Chromium的自动化编译平台。</p>
<h2 id="u9700_u6C42"><a href="#u9700_u6C42" class="headerlink" title="需求"></a>需求</h2><p>按照最初的需求，新平台包含以下功能:</p>
<ul>
<li>Auto fetch and build Chromium project at regular time.</li>
<li>Build commits according to demand.</li>
<li>Quick query to a commit and download built binaries.</li>
</ul>
<p>后来经过我提议，决定搭建一个<strong>分布式编译集群</strong>，采用Master-Slave结构，将组里淘汰下来的旧电脑充分利用，作为build worker加入Machine pool。</p>
<h2 id="u8BBE_u8BA1"><a href="#u8BBE_u8BA1" class="headerlink" title="设计"></a>设计</h2><p>系统主要分成四个模块：<strong>Master</strong>, <strong>Collector</strong>, <strong>Database</strong>, <strong>Worker</strong></p>
<p>其中的<strong>Master</strong>，<strong>Collector</strong>，<strong>Database</strong>相当于Master-Slave结构中的Master，而Worker就是Slave,<br>结构关系如下图所示：</p>
<p>TBD</p>
<ul>
<li><p><strong>Master</strong><br>通过消息队列与Worker进行交互，提供数据库管理、添加build任务等操作的API。提供Admin Site给用户进行基于Web的可视化管理。</p>
<ul>
<li>Admin Site: 给用户提供可视化的管理界面</li>
<li>Database API: 封装SQLAlchemy给其他功能提供数据库操作API</li>
<li>Database Keeper: 监听消息队列中的任务状态更新以及查询信息</li>
<li>Scheduler: 定期更新代码库并将新的代码库信息同步进数据库，同时将需要build的commit加入task队列。</li>
</ul>
</li>
<li><p><strong>Collector</strong><br>独立于Master，负责通过HTTP接收Worker build结束之后提交的log和binaries，通过Web提供查询以及下载的API。</p>
</li>
<li><p><strong>Database</strong><br>用于存储代码库的Commit以及Branch信息，Task的build情况等，驱动Master。</p>
</li>
<li><p><strong>Worker</strong><br>每个Worker维护一个Chromium的code base，通过消息队列获取build task，包括需要build的commit的commit hash或者version No.。<br>Build的过程中通过消息队列更新当前任务的完成进度以及自身状态。Build结束后将Binaries和Log打包，通过HTTP上传给Collector，并接受下一个任务。</p>
</li>
</ul>
<p>任务分发流程：</p>
<ul>
<li>添加任务：</li>
</ul>
<p>TBD</p>
<h2 id="u5B9E_u73B0"><a href="#u5B9E_u73B0" class="headerlink" title="实现"></a>实现</h2><p>技术栈：</p>
<ul>
<li>语言：Python3.4(后端)，HTML,CSS,JS(Admin Site前端)</li>
<li>Web框架：<a href="http://flask.pocoo.org/" target="_blank" rel="external">Flask</a></li>
<li>ORM工具：<a href="http://www.sqlalchemy.org/" target="_blank" rel="external">SQLAlchemy</a></li>
<li>消息队列：<a href="http://www.rabbitmq.com/" target="_blank" rel="external">RabbitMQ</a></li>
<li>数据库：<a href="https://mariadb.org/" target="_blank" rel="external">MariaDB</a></li>
</ul>
<h2 id="u62D3_u5C55"><a href="#u62D3_u5C55" class="headerlink" title="拓展"></a>拓展</h2><ul>
<li>增加邮件提醒功能，使用SMTPLib</li>
<li>使用Docker快速自动化部署Worker</li>
</ul>
<h2 id="u603B_u7ED3_26amp_3B_u611F_u60F3"><a href="#u603B_u7ED3_26amp_3B_u611F_u60F3" class="headerlink" title="总结&amp;感想"></a>总结&amp;感想</h2><p>根据需求，从设计到开发全都是一人完成，很好地锻炼了我系统模块化设计的能力。“全栈”式的开发也让我对整个系统流程有了更深的理解，为接以后的项目和工作打下了坚实基础。<br>技术发展与迭代的速度很快，不能只拘泥于工具的使用，要深入理解其背后的设计逻辑，才能应得万变。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>新学期刚开始没多久便拿到了Intel上海的实习Offer，于是选择了翘课实习，至今已经三多月了。<br>实习第一个阶段的任务便是开发一个针对Chromium的自动化编译平台。</p>
<h2 id="u9700_u6C42"><a href="#u9700_u6C42" c]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于WebSocket的网页遥控器]]></title>
    <link href="http://yoursite.com/2015/12/16/remote-control-based-on-websocket/"/>
    <id>http://yoursite.com/2015/12/16/remote-control-based-on-websocket/</id>
    <published>2015-12-15T16:00:00.000Z</published>
    <updated>2016-01-24T10:32:20.258Z</updated>
    <content type="html"><![CDATA[<h2 id="u573A_u666F"><a href="#u573A_u666F" class="headerlink" title="场景"></a>场景</h2><p>前段时间有一个小需求，场景是装着Ubuntu的笔记本放在书桌上连着音箱用网页版的网易云音乐放歌，每次睡觉前我都要从床上爬起来去手动暂停播放，十分影响舒适度。于是便希望有种方法能够通过手机远程控制播放器的暂停。</p>
<h2 id="u5B9E_u73B0"><a href="#u5B9E_u73B0" class="headerlink" title="实现"></a>实现</h2><p>由于播放器是基于Web的且我没有开发手机app的条件，于是便准备从Web着手，首选的通信方式当然是WebSocket。实现的方法是写一个Chrome的小插件，用来在网页中注入JS代码，而这段JS的功能就是与中继服务器建立WebSocket连接，并通过解析接收到的指令对网页上的元素进行对应的操作，比如click暂停/播放、下一首、上一首等按钮。</p>
<p>有一个比较关键的地方就是中继服务器实现的对于WebSocket发送内容的中继。我采用了Gorilla的WebSocket库，并在其examples/chat上进行的修改，加入了Channel的功能，即只要连上同样的URL就是加入同一个频道，来实现中继通信。<br>于是最终的流程就是：</p>
<ol>
<li>在中继服务器上建立Web Server</li>
<li>控制端访问获取控制页面，页面上的JS使用WebSocket加入Channel A</li>
<li>被控制端在需要控制的网页注入JS，同样加入Channel A</li>
<li>控制端与被控制端建立通信</li>
</ol>
<p>源代码：<a href="https://github.com/prikevs/WSChannel" target="_blank" rel="external">github</a></p>
<h2 id="u62D3_u5C55"><a href="#u62D3_u5C55" class="headerlink" title="拓展"></a>拓展</h2><p>可以作为网页遥控器来使用，比如控制基于Web的PPT等。</p>
<h2 id="u540E_u8BB0"><a href="#u540E_u8BB0" class="headerlink" title="后记"></a>后记</h2><p>直到我后来发现了peer.js，才发现自己走到沟里去了……</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u573A_u666F"><a href="#u573A_u666F" class="headerlink" title="场景"></a>场景</h2><p>前段时间有一个小需求，场景是装着Ubuntu的笔记本放在书桌上连着音箱用网页版的网易云音乐放歌，每次睡觉]]>
    </summary>
    
      <category term="websocket" scheme="http://yoursite.com/tags/websocket/"/>
    
  </entry>
  
</feed>
